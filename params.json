{"name":"ImportIO Java Facilitator","tagline":"Making ImportIO simpler with Java.","body":"# Introduction\r\nFacilitator is a project that aims to integrate ImportIO better in Java apps by caching and parsing data retrieved by ImportIO.\r\nThis project is just a hobby and is not affiliated with ImportIO.\r\n\r\n# Features\r\n## Integration with POJOs\r\nFacilitator provides an easy and quick way to get POJOs out of your data. Let's see how.\r\n### Create an IOClient's instance.\r\nIOClient is a special subclass of ImportIO that provides all the tools to parse your data.\r\n```java\r\nIOClient client = new IOClient(\"YOURUSERID\", \"YOURSECRETKEY\");\r\n```\r\n#### Notes\r\n  * You don't have to use UUID class to handler your user id, IOClient will do it for you.\r\n\r\n### Create a classic ImportIO Query.\r\nYour query can be almost anything, bug some types are not currently handled. See below.\r\n\r\n### Get a POJO class ready to handle you data.\r\nMark the fields you want to fill with @Attribute(\"name\") annotation with \"name\" being the column name of your data in ImportIO. Here's an example that could describe a product from a website such as Amazon.\r\n```java\r\nclass Product\r\n{\r\n  @Id\r\n  protected long id;\r\n  @Attribute(\"name\")\r\n  protected String name;\r\n  @Attribute(\"image\")\r\n  protected String imageUrl;\r\n  @Attribute(\"price\")\r\n  protected Money price;\r\n  ...\r\n  protected Integer someOtherField\r\n  ...\r\n}\r\n```\r\nSome special classes such as Date and Money are handled by Facilitator, which means if your field represent a date, its class could be either Date, Long (in which case it will correspond to the timestamp), or String (it will correspond to the date as a string). Here's a quick table of compatible types and classes:\r\n\r\n| Types | Classes                             | Value                                                     |\r\n|-------|-------------------------------------|-----------------------------------------------------------|\r\n| Date  | java.util.Date<br/>Long<br/>String  | -<br/>timestamp<br/>literal date                          |\r\n| Money | org.joda.money.Money<br/>Double<br/>String         | -<br/>Amount of money<br/>Amount of money + currency sign |\r\n\r\n#### Notes\r\n  * @Id attribute allows you to get the id of the row\r\n\r\n### Use your IOClient to query the server\r\nIt will get you a list of POJO instances. You will have to tell the client which class it should generate (here, Product.class)\r\n```java\r\nList<Product> products = client.populate(query, Product.class);\r\n```\r\n#### Notes\r\n  * By default, the client will cache request in memory, so if you execute the same query multiple times, it won't get fresh data. To change this behaviour pass a third argument to populate like `client.populate(query, Product.class, true);`\r\n\r\n## In-memory caching\r\nFacilitator automatically cache all the queries you make (actually no more than 200 to save memory) with a TTL of one hour. Which means that if you call populate() again with the same query, it won't reload fresh data unless you force refresh (passing true a the third parameter) or the TTL has expired.\r\n\r\n# Customize\r\nFacilitator has been built so you can extend it to automatically parse your data and fit it into POJOs. If you want to add your own parser, this is actually quite simple. Explanations coming soon.\r\n\r\n# Authors and Contributors\r\n* Original Author: @thuzhen\r\n* Awesome money implementation: @JodaOrg (https://github.com/JodaOrg/joda-money)\r\n* Caching uses Kitty-cache (http://code.google.com/p/kitty-cache/)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}